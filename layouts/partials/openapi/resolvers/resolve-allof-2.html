{{ $ret := . }}
{{ $original := . }}

{{ with $ret.allOf }}

    {{ $all_of_values := dict }}

    {{/* allOf is always an array */}}

    {{/* we need to concat "required" values */}}
    {{ $required := slice }}
    {{ range . }}

        {{/* with merge, values from the second argument override those from the first argument */}}
        {{/* so this order will accumulate values from allOf items, allowing later ones to override earlier */}}
        {{ $all_of_values = merge $all_of_values . }}

    {{ end }}

    {{/* then apply allOf values to the original, but allow the original to override allOf */}}
    {{ $ret = merge $all_of_values $ret }}

    {{/* except that if allOf _itself_ contains allOf, we do want to override the original for that field only */}}
    {{ with $all_of_values.allOf }}
        {{ $ret = merge $ret (dict "allOf" . ) }}
    {{ end }}

{{ end }}

{{/* recurse while we are finding new allOf entries to resolve */}}
{{ if ne $ret.allOf $original.allOf }}

    {{ $resolved := partial "openapi/resolvers/resolve-allof" $ret }}
    {{ $ret = merge $ret $resolved }}

{{ end }}

{{ return $ret }}
