{{/*

  This template is included at the end of each page's `<body>`.

  We're using it here to:

  1) include the JS that generates the table of contents. It would be better
  to generate the table of contents as part of the Hugo build process, but
  that doesn't work nicely with the way we want to author client-server modules
  as separate files.

  2) highlight and scroll the ToC in the sidebar to match the place we are at
  in the document.

*/}}

<script>

  /*
  Account for id attributes that are in the sidebar nav
  */
  function populateIds() {
    const navItems = document.querySelectorAll(".td-sidebar-nav li");
    return Array.from(navItems).map(item => item.id).filter(id => id != "");
  }

  /*
  Given an ID and an array of IDs, return s version of the original ID that's
  not equal to any of the IDs in the array.
  */
  function uniquify(id, uniqueIDs) {
    const baseId = id;
    let counter = 0;
    while (uniqueIDs.includes(id)) {
      counter = counter + 1;
      id = baseId + "-" + counter.toString();
    }
    return id;
  }

  /*
  Given an array of heading nodes, ensure they all have unique IDs.

  We have to do this mostly because of client-server modules, which are
  rendered separately then glued together with a template.
  Because heading IDs are generated in rendering, this means they can and will
  end up with duplicate IDs.
  */
  function fixHeadingIds(headings) {
    const uniqueIDs = populateIds();
    for (let heading of headings) {
      const uniqueID = uniquify(heading.id, uniqueIDs);
      uniqueIDs.push(uniqueID);
      heading.id = uniqueID;
    }
  }

  /*
  Generate a table of contents based on the headings in the document.
  */
  function makeToc() {

    // make the title from the H1
    const h1 = document.body.querySelector("h1");
    const title = document.createElement("a");
    title.id = "toc-title";
    title.setAttribute("href", "#");
    title.textContent = h1.textContent;

    // make the content
    const content = document.body.querySelector(".td-content");
    let headings = [].slice.call(content.querySelectorAll("h2, h3, h4, h5, h6"));
    // we'll omit headings that don't have IDs.
    headings = headings.filter(heading => heading.id);
    // we have to adjust heading IDs to ensure that they are unique
    fixHeadingIds(headings);
    const nav = document.createElement("nav");
    nav.id = "TableOfContents";

    const section = makeTocSection(headings, 0);
    nav.appendChild(section.content);
    // append title and content to the #toc placeholder
    const toc = document.body.querySelector("#toc");
    toc.appendChild(title);
    toc.appendChild(nav);
  }

  // create a single ToC entry
  function makeTocEntry(heading) {
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.setAttribute("href", `#${heading.id}`);
    a.textContent = heading.textContent;
    li.appendChild(a);
    return li;
  }

  /*
  Each ToC section is an `<ol>` element.
  ToC entries are `<li>` elements and these contain nested ToC sections,
  whenever we go to the next heading level down.
  */
  function makeTocSection(headings, index) {
    const ol = document.createElement("ol");
    let previousHeading = null;
    let previousLi = null;
    let i = index;
    const lis = [];

    for (i; i < headings.length; i++) {
      const thisHeading = headings[i];
      if (previousHeading && (thisHeading.tagName > previousHeading.tagName)) {
        // we are going down a heading level, create a new nested section
        const section = makeTocSection(headings, i);
        previousLi.appendChild(section.content);
        i = section.index -1;
      }
      else if (previousHeading && (previousHeading.tagName > thisHeading.tagName)) {
        // we have come back up a level, so a section is finished
        for (let li of lis) {
          ol.appendChild(li);
        }
        return {
          content: ol,
          index: i
        }
      }
      else {
        // we are still processing this section, so add this heading to the current section
        previousLi = makeTocEntry(thisHeading);
        lis.push(previousLi);
        previousHeading = thisHeading;
      }
    }
    for (let li of lis) {
      ol.appendChild(li);
    }
    return  {
      content: ol,
      index: i
    }
  }

  makeToc();

  /*
  Set a new ToC entry.
  Clear any previously highlighted ToC items, set the new one,
  and adjust the ToC scroll position.
  */
  function setTocEntry(newEntry) {
    const activeEntries = document.querySelectorAll("#toc a.active");
    for (const activeEntry of activeEntries) {
      activeEntry.classList.remove('active');
    }

    newEntry.classList.add('active');

    // don't scroll the nav if the main content is not scrolled
    const nav = document.querySelector("#td-section-nav");
    const content = document.querySelector("html");
    if (content.scrollTop !== 0) {
      nav.scrollTop = newEntry.offsetTop - 100;
    } else {
      nav.scrollTop = 0;
    }
  }

  /*
  Test whether a node is in the viewport
  */
  function isInViewport(node) {
    const rect = node.getBoundingClientRect();

    return (
      rect.top >= 0 &&
      rect.left >= 0 &&
      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
      rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );
  }

  /*
  Track when headings enter the viewport, and use this to update the highlight
  for the corresponding ToC entry.
  */
  window.addEventListener('DOMContentLoaded', () => {

    const toc = document.querySelector("#toc");
    toc.addEventListener("click", event => {
      if (event.target.tagName === "A") {
        setTocEntry(event.target);
      }
    });

    const observer = new IntersectionObserver(entries => {

      /*
      Special case: If the current URL hash matches a ToC entry, and
      the corresponding heading is visible in the viewport, then that is
      made the current ToC entry, and we don't even look at the intersection
      observer data.
      This means that if the user has clicked on a ToC entry,
      we won't unselect it through the intersection observer.
      */
      const hash = document.location.hash;
      if (hash) {
        const tocEntryForHash = document.querySelector(`nav li a[href="${hash}"]`);
        if (tocEntryForHash) {
          const headingForHash = document.querySelector(hash);
          if (headingForHash && isInViewport(headingForHash)) {
            setTocEntry(tocEntryForHash);
            return;
          }
        }
      }

      let newEntry = null;

      for (const entry of entries) {
        if (entry.intersectionRatio > 0) {
          const heading = entry.target;
          /*
          If the H1 (title) has started intersecting, then just scroll the nav
          back to the top. This enables us to show the sitenav
          in the sidebar when the user scrolls back up to the top.
          */
          if (heading.tagName === "H1") {
            const nav = document.querySelector("#td-section-nav");
            nav.scrollTop = 0;
            return;
          }
          /*
          Otherwise, get the ToC entry for the first entry that
          entered the viewport, if there was one.
          */
          const id = entry.target.getAttribute('id');
          const tocEntry = document.querySelector(`nav li a[href="#${id}"]`);
          if (tocEntry && !newEntry) {
            newEntry = tocEntry;
          }
        }
      }

      if (newEntry) {
        setTocEntry(newEntry);
        return;
      }

  });

  document.querySelectorAll(".td-content>h1, h2, h3, h4, h5, h6").forEach((section) => {
    observer.observe(section);
  });

  });

</script>
