{{/*

  This template is included at the end of each page's `<body>`.

  We're using it here to:

  1) include the JS that generates the table of contents. It would be better
  to generate the table of contents as part of the Hugo build process, but
  that doesn't work nicely with the way we want to author client-server modules
  as separate files.

  2) highlight and scroll the ToC in the sidebar to match the place we are at
  in the document.

*/}}

<script>

  /*
  Account for id attributes that are in the sidebar nav
  */
  function populateIds() {
    const navItems = document.querySelectorAll(".td-sidebar-nav li");
    return Array.from(navItems).map(item => item.id).filter(id => id != "");
  }

  /*
  Given an ID and an array of IDs, return s version of the original ID that's
  not equal to any of the IDs in the array.
  */
  function uniquify(id, uniqueIDs) {
    const baseId = id;
    let counter = 0;
    while (uniqueIDs.includes(id)) {
      counter = counter + 1;
      id = baseId + "-" + counter.toString();
    }
    return id;
  }

  /*
  Given an array of heading nodes, ensure they all have unique IDs.

  We have to do this mostly because of client-server modules, which are
  rendered separately then glued together with a template.
  Because heading IDs are generated in rendering, this means they can and will
  end up with duplicate IDs.
  */
  function fixHeadingIds(headings) {
    const uniqueIDs = populateIds();
    for (let heading of headings) {
      const uniqueID = uniquify(heading.id, uniqueIDs);
      uniqueIDs.push(uniqueID);
      heading.id = uniqueID;
    }
  }

  /*
  Generate a table of contents based on the headings in the document.
  */
  function makeToc() {

    // make the title from the H1
    const h1 = document.body.querySelector("h1");
    const title = document.createElement("a");
    title.id = "toc-title";
    title.setAttribute("href", "#");
    title.textContent = h1.textContent;

    // make the content
    const content = document.body.querySelector(".td-content");
    let headings = [].slice.call(content.querySelectorAll("h2, h3, h4, h5, h6"));
    // we'll omit headings that don't have IDs.
    headings = headings.filter(heading => heading.id);
    // we have to adjust heading IDs to ensure that they are unique
    fixHeadingIds(headings);
    const nav = document.createElement("nav");
    nav.id = "TableOfContents";

    const section = makeTocSection(headings, 0);
    nav.appendChild(section.content);
    // append title and content to the #toc placeholder
    const toc = document.body.querySelector("#toc");
    toc.appendChild(title);
    toc.appendChild(nav);
  }

  // create a single ToC entry
  function makeTocEntry(heading) {
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.setAttribute("href", `#${heading.id}`);
    a.textContent = heading.textContent;
    li.appendChild(a);
    return li;
  }

  /*
  Each ToC section is an `<ol>` element.
  ToC entries are `<li>` elements and these contain nested ToC sections,
  whenever we go to the next heading level down.
  */
  function makeTocSection(headings, index) {
    const ol = document.createElement("ol");
    let previousHeading = null;
    let previousLi = null;
    let i = index;
    const lis = [];

    for (i; i < headings.length; i++) {
      const thisHeading = headings[i];
      if (previousHeading && (thisHeading.tagName > previousHeading.tagName)) {
        // we are going down a heading level, create a new nested section
        const section = makeTocSection(headings, i);
        previousLi.appendChild(section.content);
        i = section.index -1;
      }
      else if (previousHeading && (previousHeading.tagName > thisHeading.tagName)) {
        // we have come back up a level, so a section is finished
        for (let li of lis) {
          ol.appendChild(li);
        }
        return {
          content: ol,
          index: i
        }
      }
      else {
        // we are still processing this section, so add this heading to the current section
        previousLi = makeTocEntry(thisHeading);
        lis.push(previousLi);
        previousHeading = thisHeading;
      }
    }
    for (let li of lis) {
      ol.appendChild(li);
    }
    return  {
      content: ol,
      index: i
    }
  }

  makeToc();

  /*
  Track when headings enter the viewport, and use this to update the highlight
  for the corresponding ToC entry.
  */
  window.addEventListener('DOMContentLoaded', () => {

    const observer = new IntersectionObserver(headings => {
      let newEntry = null;

      /*
      Get the ToC entry for the first entry that entered the viewport, if there
      was  one.
      */
      for (const heading of headings) {
        if (heading.intersectionRatio > 0) {
          const id = heading.target.getAttribute('id');
          const entry = document.querySelector(`nav li a[href="#${id}"]`);
          if (entry) {
            newEntry = entry;
            break;
          }
        }
    }

      /*
      If a new heading did enter the viewport, clear any previously
      highlighted ToC items, set the new one, and adjust the ToC scroll position.
      */
      if (newEntry) {
        const activeEntries = document.querySelectorAll("#toc a.active");
        for (const activeEntry of activeEntries) {
          activeEntry.classList.remove('active');
        }

        newEntry.classList.add('active');
        const nav = document.querySelector("#td-section-nav");
        nav.scrollTop = newEntry.offsetTop - 100;
      }

  });

  // Track all headings
  document.querySelectorAll("h2, h3, h4, h5, h6").forEach((section) => {
    observer.observe(section);
  });

  });

</script>
